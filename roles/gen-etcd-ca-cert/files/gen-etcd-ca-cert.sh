#!/bin/bash

# Copyright 2017 The Kubernetes Authors.
#
# Licensed under the Apache License, Version 2.0 (the "License");
# you may not use this file except in compliance with the License.
# You may obtain a copy of the License at
#
#     http://www.apache.org/licenses/LICENSE-2.0
#
# Unless required by applicable law or agreed to in writing, software
# distributed under the License is distributed on an "AS IS" BASIS,
# WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
# See the License for the specific language governing permissions and
# limitations under the License.

set -o errexit
set -o nounset
set -o pipefail

# Export proxy to ensure commands like curl could work
[[ -n "${HTTP_PROXY:-}" ]]  && export HTTP_PROXY=${HTTP_PROXY}
[[ -n "${HTTPS_PROXY:-}" ]] && export HTTPS_PROXY=${HTTPS_PROXY}

# Caller should set in the ev:
# NODE_IPS - IPs of all etcd servers
# NODE_DNS - DNS names of all etcd servers
# ARCH - what arch of cfssl should be downloaded

# Also the following will be respected
# CERT_DIR - where to place the finished certs
# CERT_GROUP - who the group owner of the cert files should be
# MASTER_CA_DIR - copy master ca files from this directory
# MATER_CA_CONFIG_DIR - copy master ca-config from this directory


# parse environment variables for internal use

node_ips="${NODE_IPS:="${1}"}"
node_dns="${NODE_DNS:=""}"
arch="${ARCH:-"linux-amd64"}"
cert_dir="${CERT_DIR:="${1}"}"
#cert_group="${CERT_GROUP:="etcd"}"
cert_group="${CERT_GROUP:="root"}"
master_ca_config_dir="${MASTER_CA_CONFIG_DIR:="${1}"}"
master_ca_dir="${MASTER_CA_DIR:="${1}"}"

# end env parse

# Following certificate pairs are created:
#
#  - etcd-ca (the etcd cluster's certificate authority)
#  - etcd-server (for etcd access)
#  - etcd-client (for kube-apiserver, etcdctl)
#  - etcd-peer (for etcd peer to peer communication)

declare -a san_array=()

IFS=',' read -ra node_ips <<< "$node_ips"
for ip in "${node_ips[@]}"; do
    san_array+=(${ip})
done
IFS=',' read -ra node_dns <<< "$node_dns"
for dns in "${node_dns[@]}"; do
    san_array+=(${dns})
done

# add cfssl utility bin directory to path (/usr/local/bin)
#   - as basic bash path do not include /usr/local/bin which cfssl utility reside in
export PATH="$PATH:/usr/local/bin"

# enter work directory to create kube ca cert
cd "${cert_dir}"


# debug log
pwd > trace.log
echo ${PATH} >> trace.log
echo ${cert_dir} >> trace.log
echo ${node_ips} >> trace.log
echo ${node_dns} >> trace.log
echo ${arch} >> trace.log
echo ${cert_group} >> trace.log
echo ${master_ca_config_dir} >> trace.log
echo ${master_ca_dir} >> trace.log
# end log

####    Generate CA CERT    #####################################################################

# get hosts string (include ip address list and hostname list of cluster masters)

cn_name="${san_array[0]}"
san_array=("${san_array[@]}")
set -- ${san_array[*]}
for arg do shift
    set -- "$@" \",\" "$arg"
done; shift
hosts_string="\"$(printf %s "$@")\""


# debug trace log
echo ${hosts_string} >> trace.log
# end log

# 1. etcd-server
#    generate etcd server csr json
cat <<EOF > etcd-server-csr.json
{
    "CN": "etcd",
    "hosts": [
        "127.0.0.1",
        "::1",
        "::",
        $hosts_string
    ],
    "key": {
        "algo": "rsa",
        "size": 2048
    },
    "names": [
        {
            "O": "autogenerated",
            "OU": "etcd cluster",
            "L": "internet"
        }
    ]
}
EOF

# debug trace log
echo "finished etcd-server-csr.json" >> trace.log
# end debug 

if ! (cfssl gencert -ca=ca.pem -ca-key=ca-key.pem -config=ca-config.json -profile=server etcd-server-csr.json | cfssljson -bare etcd-server) >/dev/null 2>&1; then
    echo "=== Failed to generate server certificates: Aborting ===" 1>&2
    exit 2
fi

# debug trace log
echo "finished gen etcd-server cert" >> trace.log
# end debug

# 2. etcd-client 
#    generate etcd-client csr json file
cat <<EOF > etcd-client-csr.json
{
    "CN": "etcd",
    "hosts": [""],
    "key": {
        "algo": "rsa",
        "size": 2048
    },
    "names": [
        {
            "O": "autogenerated",
            "OU": "etcd cluster",
            "L": "the internet"
        }
    ]
}
EOF

# debug
#ls -al ./* > "${cert_dir}/files2.txt"
#cat ./etcd-client.json > "${cert_dir}/etcd-client.json"
#cat ./ca-csr.json > "${cert_dir}/ca-csr.json"

if ! (cfssl gencert -ca=ca.pem -ca-key=ca-key.pem -config=ca-config.json -profile=client etcd-client-csr.json | cfssljson -bare etcd-client) >/dev/null 2>&1; then
    echo "=== Failed to generate client certificates: Aborting ===" 1>&2
    exit 2
fi 


# 3. etcd peer csr
##   generate etcd peer csr json
cat <<EOF > etcd-peer-csr.json
{
    "CN": "etcd",
    "hosts": [
        "127.0.0.1",
        "::1",
        "::",
        $hosts_string
    ],
    "key": {
        "algo": "rsa",
        "size": 2048
    },
    "names": [
        {
            "O": "autogenerated",
            "OU": "etcd cluster",
            "L": "the internet"
        }
    ]
}
EOF

# debug
#ls -al ./* > "${cert_dir}/files3.txt"
#cat ./etcd-peer.json > "${cert_dir}/etcd-peer.json"
#cat ./ca-csr.json > "${cert_dir}/ca-csr.json"

if ! (cfssl gencert -ca=ca.pem -ca-key=ca-key.pem -config=ca-config.json -profile=peer etcd-peer-csr.json | cfssljson -bare etcd-peer) >/dev/null 2>&1; then
    echo "=== Failed to generate peer certificates: Aborting ===" 1>&2
    exit 2
fi

# 4. flanneld client
#    generate flanneld client csr json file
cat <<EOF > flanneld-csr.json
{
    "CN": "flanneld",
    "hosts": [""],
    "key": {
        "algo": "rsa",
        "size": 2048
    },
    "names": [
        {
            "O": "kubernetes",
            "OU": "kube cluster",
            "L": "the internet"
        }
    ]
}
EOF

# debug
# end debug

if ! (cfssl gencert -ca=ca.pem -ca-key=ca-key.pem -config=ca-config.json -profile=client flanneld-csr.json | cfssljson -bare flanneld) >/dev/null 2>&1; then
    echo "=== Failed to generate client certificates: Aborting ===" 1>&2
    exit 2
fi

# debug trace log
echo "finished gen etcd and flanneld cert" >> trace.log
# end debug
